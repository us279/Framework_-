#!/usr/bin/env python3
"""
Plot results from Fortran FEM simulations at different precision levels.
This script reads CSV files generated by the Fortran codes and creates
comparative visualizations in a dedicated output directory.
"""

import os
import glob
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from pathlib import Path
import shutil

BASE_DIR = os.path.dirname(__file__)
DATA_DIR = os.path.join(BASE_DIR, "csv outputs")
# Add error directory constant
ERROR_DIR = os.path.join(BASE_DIR, "errors")

# Set output directory
OUTPUT_DIR = "plot_outputs"

# Color scheme for different precision levels
COLORS = {
    'FP16': '#FF5733',  # Orange-red
    'FP32': '#33A8FF',  # Light blue
    'FP64': '#4CAF50',  # Green
    'FP128': '#9C27B0', # Purple
}

def ensure_output_dir():
    """Create output directory if it doesn't exist."""
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)
        print(f"Created output directory: {OUTPUT_DIR}")
    else:
        print(f"Using existing output directory: {OUTPUT_DIR}")

def ensure_error_dir():
    """Create errors directory if it doesn't exist."""
    if not os.path.exists(ERROR_DIR):
        os.makedirs(ERROR_DIR)
        print(f"Created errors directory: {ERROR_DIR}")
    else:
        print(f"Using existing errors directory: {ERROR_DIR}")

def read_csv_file(filename):
    """Read a CSV file with x and u columns."""
    try:
        # Read the CSV file
        #df = pd.read_csv(filename)
        df = pd.read_csv(filename, sep=r'[,\s]+', engine='python')
        
        # Convert column headers to lowercase for consistency
        df.columns = [col.lower() for col in df.columns]
        
        # Make sure 'u' column is numeric
        if 'u' in df.columns:
            df['u'] = pd.to_numeric(df['u'], errors='coerce')
            
        return df
    except Exception as e:
        print(f"Error reading {filename}: {e}")
        return None

def load_quantity_trace(eq_type, precision):
    """
    Read the <eq>_<precision>_(entropy|momentum|energy).csv produced by the
    Fortran runs and return (t, Q/Q0) where Q0 is the first-row value.
    Returns None if the file does not exist.
    """
    # pick the right CSV suffix for each equation
    tag = {'advection': 'entropy',
           'burgers':   'momentum',
           'heat':      'mass'}[eq_type]

    fn = os.path.join(DATA_DIR, f"{eq_type}_{precision}_{tag}.csv")
    if not os.path.exists(fn):
        return None

    try:
        #df = pd.read_csv(fn)
        df = pd.read_csv(fn, sep=r'[,\s]+', engine='python')
        
        # For advection, we now plot entropy directly
        if eq_type == 'advection':
            t = df['time']
            # Use the 'E' column (entropy) - typically column index 2
            # Find entropy column - usually 3rd column
            if 'e' in [col.lower() for col in df.columns]:
                # Find the column with name 'E' (case insensitive)
                for col in df.columns:
                    if col.lower() == 'e':
                        entropy = df[col]
                        return t, entropy
            
            # Fallback to column index
            entropy = df.iloc[:, 2]  # The entropy column (3rd column)
            return t, entropy
        else:
            # For Burgers and Heat, just return the absolute quantity in col 3
            # (no division by an almost-zero q0)
            t = df['time']
            qn = df.iloc[:, 2]
            return t, qn
            
    except Exception as e:
        print(f"   ↳ cannot read {fn}: {e}")
        return None

def read_error_file(equation_type, precision):
    """Read error metrics from file if available."""
    filename = os.path.join(DATA_DIR,f"{equation_type}_{precision}_errors.txt")

    errors = {'L1': None, 'L2': None, 'Linf': None}
    
    if os.path.exists(filename):
        try:
            with open(filename, 'r') as f:
                lines = f.readlines()
                for line in lines:
                    if 'L1 Error:' in line:
                        errors['L1'] = float(line.split(':')[1].strip())
                    elif 'L2 Error:' in line:
                        errors['L2'] = float(line.split(':')[1].strip())
                    elif 'Linf Error:' in line:
                        errors['Linf'] = float(line.split(':')[1].strip())
            print(f"Read error metrics from {filename}")
        except Exception as e:
            print(f"Error reading {filename}: {e}")
    
    return errors

def extract_time_from_csv(filename):
    """Extract time value from CSV header if present."""
    try:
        with open(filename, 'r') as f:
            header = f.readline().strip()
            if 'time=' in header:
                time_part = header.split('time=')[1]
                return float(time_part)
    except:
        pass
    return None

def plot_conservation(eq_type, precision_list):
    """
    For a given PDE plot the conserved/decaying quantity for each precision.
    Saves <eq_type>_conservation.png in OUTPUT_DIR.
    """
    label_map = {
      'advection': 'Entropy (E)',
      'burgers':   'Momentum (M)',
      'heat':      'Mass (M)'
    }

    plt.figure(figsize=(10, 6))
    found_any = False

    for prec in precision_list:
        data = load_quantity_trace(eq_type, prec)
        if data is None:
            continue
        t, qn = data
        if eq_type == 'advection':
            plt.plot(t, qn, label=prec, color=COLORS.get(prec), lw=2)
        else:
            # Burgers → M(t), Heat → mass(t)
            plt.plot(t, qn, label=prec, color=COLORS.get(prec), lw=2)
        found_any = True

    if not found_any:
        print(f"   ↳ No conservation files for {eq_type}")
        plt.close(); return

    plt.xlabel('Time')
    plt.ylabel(label_map[eq_type])
    # Mass and momentum will be O(1e-20…) around zero—keep a linear scale
    # if you want to highlight drift you can add:
    #    plt.axhline(0, color='k', ls='--', lw=1)
    # else leave on linear axes to see sign changes
    
    # Update title for advection to reflect entropy values
    if eq_type == 'advection':
        plt.title(f"{eq_type.capitalize()} – Entropy vs Time")
    else:
        plt.title(f"{eq_type.capitalize()} – Conservation vs Time")
    # lightly grid for readability
    plt.grid(True, alpha=0.3)
    
    plt.legend()
    plt.yscale('log')
    outfile = os.path.join(OUTPUT_DIR, f"{eq_type}_conservation.png")
    plt.savefig(outfile, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"   ↳ saved conservation plot → {outfile}")

def create_single_plot(equation_type, precision_list=None):
    """Create a plot comparing the final state for different precision levels."""
    if precision_list is None:
        precision_list = ['FP32','FP64','FP128']
        if glob.glob(os.path.join(DATA_DIR, f"{equation_type}_FP16_summary.csv")):
            precision_list.insert(0,'FP16')

    
    plt.figure(figsize=(10, 6))
    
    # Plot analytical solution if available
    if equation_type == 'advection':
        x = np.linspace(0, 1, 1000)
        t = 0.5  # End time
        a = 2.0  # Advection speed
        u_exact = np.sin(2 * np.pi * (x - a * t))
        plt.plot(x, u_exact, 'k--', label='Exact Solution', linewidth=1.5)
    
    # Plot numerical solutions
    for precision in precision_list:
        summary_fn = os.path.join(DATA_DIR, f"{equation_type}_{precision}_summary.csv")
        if os.path.exists(summary_fn):
            df = read_csv_file(summary_fn)
            if df is not None and 'x' in df.columns and 'u' in df.columns:
                plt.plot(df['x'], df['u'], label=f'{precision}', 
                         color=COLORS.get(precision), linewidth=2)
    
    plt.title(f'{equation_type.capitalize()} Equation - Final State Comparison')
    plt.xlabel('x')
    plt.ylabel('u')
    plt.grid(True, alpha=0.3)
    plt.legend()
    
    # Save figure to output directory
    output_file = os.path.join(OUTPUT_DIR, f"{equation_type}_precision_comparison.png")
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"Saved comparison plot to {output_file}")

def create_animation(eq_type, precision):
    """Create an animation of the solution evolution for a specific precision."""
    files = sorted(glob.glob(os.path.join(DATA_DIR, f"{eq_type}_{precision}_*.csv")))
    files = sorted(glob.glob(os.path.join(DATA_DIR, f"{eq_type}_{precision}_*.csv")) + glob.glob(os.path.join(DATA_DIR, f"{eq_type}_{precision}*.csv")))

    
    if not files:
        print(f"No files found for {eq_type} at {precision} precision")
        return
    
    # Filter out summary file
    files = [f for f in files if 'summary' not in f and 'errors' not in f]
    
    # Read the first file to set up the figure
    df_first = read_csv_file(files[0])
    if df_first is None:
        return
    
    fig, ax = plt.subplots(figsize=(10, 6))
    line, = ax.plot([], [], lw=2, color=COLORS.get(precision, 'blue'))
    
    # Add exact solution if available
    if eq_type == 'advection':
        x_exact = np.linspace(0, 1, 1000)
        line_exact, = ax.plot([], [], 'k--', label='Exact Solution', linewidth=1.5)
    
    # Set up plot limits
    x_min, x_max = df_first['x'].min(), df_first['x'].max()
    
    # Carefully collect u values, ensuring they're all numeric
    u_values = []
    for file in files:
        df = read_csv_file(file)
        if df is not None and 'u' in df.columns:
            # Convert u values to float and add to list
            numeric_values = df['u'].dropna().astype(float).tolist()
            u_values.extend(numeric_values)
    
    # Calculate min and max of u values if we have any
    if u_values:
        u_min, u_max = min(u_values), max(u_values)
        # Add some padding
        u_range = max(abs(u_max - u_min), 0.1)  # Ensure range is non-zero
        u_min -= 0.1 * u_range
        u_max += 0.1 * u_range
    else:
        # Default values if no data
        u_min, u_max = -1.5, 1.5
    
    ax.set_xlim(x_min, x_max)
    ax.set_ylim(u_min, u_max)
    ax.set_xlabel('x')
    ax.set_ylabel('u')
    ax.grid(True, alpha=0.3)
    
    # Time display
    time_text = ax.text(0.02, 0.95, '', transform=ax.transAxes)
    
    def init():
        line.set_data([], [])
        time_text.set_text('')
        if eq_type == 'advection':
            line_exact.set_data([], [])
            return line, time_text, line_exact
        return line, time_text
    
    def update(frame):
        file = files[frame]
        df = read_csv_file(file)
        if df is not None and 'x' in df.columns and 'u' in df.columns:
            line.set_data(df['x'], df['u'])
            
            # Update time text
            time_value = extract_time_from_csv(file)
            if time_value is not None:
                time_text.set_text(f'Time: {time_value:.3f}')
            
            # Update exact solution if applicable
            if eq_type == 'advection' and time_value is not None:
                a = 2.0  # Advection speed
                u_exact = np.sin(2 * np.pi * (x_exact - a * time_value))
                line_exact.set_data(x_exact, u_exact)
                return line, time_text, line_exact
        
        return line, time_text
    
    # Save the animation to output directory
    output_file = os.path.join(OUTPUT_DIR, f"{eq_type}_{precision}_animation.gif")
    ani = FuncAnimation(fig, update, frames=len(files),
                        init_func=init, blit=True, interval=200)
    ani.save(output_file, writer='pillow', fps=5)
    plt.close()
    print(f"Saved animation to {output_file}")

def create_error_comparison(equation_type):
    """Compare errors across precision levels for advection equation."""
    
    plt.figure(figsize=(10, 6))
    
    # Define precision levels to check
    precision_list = ['FP32', 'FP64', 'FP128']
    pattern = os.path.join(DATA_DIR, f"{equation_type}_FP16_summary.csv")
    if glob.glob(pattern):
        precision_list.insert(0,'FP16')
    
    # Calculate or read errors
    errors = []
    for precision in precision_list:
        # First, try to read errors from error file
        error_metrics = read_error_file(equation_type, precision)
        
        if error_metrics['L1'] is not None:
            # Use pre-computed errors from file
            errors.append({
                'precision': precision,
                'L1 Error': error_metrics['L1'],
                'L2 Error': error_metrics['L2'],
                'Linf Error': error_metrics['Linf']
            })
        else:
            # Calculate errors by comparing with exact solution
            filename = os.path.join(DATA_DIR,f"{equation_type}_{precision}_summary.csv")
            if os.path.exists(filename):
                df = read_csv_file(filename)
                if df is not None and 'x' in df.columns and 'u' in df.columns:
                    # Calculate exact solution
                    x = df['x'].values
                    t = 0.5  # End time
                    a = 2.0  # Advection speed
                    u_exact = np.sin(2 * np.pi * (x - a * t))
                    
                    # Calculate error norms
                    u_num = df['u'].values
                    l1_error = np.mean(np.abs(u_num - u_exact))
                    l2_error = np.sqrt(np.mean((u_num - u_exact)**2))
                    linf_error = np.max(np.abs(u_num - u_exact))
                    
                    # Ensure errors are positive and non-zero
                    epsilon = 1e-10
                    l1_error = max(l1_error, epsilon)
                    l2_error = max(l2_error, epsilon)
                    linf_error = max(linf_error, epsilon)
                    
                    errors.append({
                        'precision': precision,
                        'L1 Error': l1_error,
                        'L2 Error': l2_error,
                        'Linf Error': linf_error
                    })
    
    # Create bar chart
    if errors:
        df_errors = pd.DataFrame(errors)

        # Save error table to CSV in the errors directory
        ensure_error_dir()  # Make sure the errors directory exists
        error_csv_file = os.path.join(ERROR_DIR, f"{equation_type}_errors.csv")
        df_errors.to_csv(error_csv_file, index=False)
        print(f"Saved error table to {error_csv_file}")

        # get the scalar FP128 error for each norm
        fp128 = df_errors[df_errors['precision']=='FP128'].squeeze()
        # subtract it so FP128 → 0, others → (error_FP{X} - error_FP128)
        for col in ['L1 Error','L2 Error','Linf Error']:
            df_errors[col] = df_errors[col] - fp128[col]


        print(df_errors.to_string(index=False, float_format='%.8e'))
        
        # Check if we have valid error values for plotting
        if len(df_errors) > 0:
            ax = plt.subplot(111)
            bar_width = 0.25
            index = np.arange(len(df_errors['precision']))
            
            # Plot error bars
            ax.bar(index,             df_errors['L1 Error'],   bar_width, label='ΔL1 Error', color = 'blue')
            ax.bar(index+bar_width,   df_errors['L2 Error'],   bar_width, label='ΔL2 Error', color = 'green' )
            ax.bar(index+2*bar_width, df_errors['Linf Error'], bar_width, label='ΔLinf Error', color = 'red')


            ax.set_yscale('log')
            
            ax.set_xlabel('Precision')
            ax.set_ylabel('Δ Error from FP128')
            ax.set_title('Absolute Error Difference vs. FP128')
            ax.set_xticks(index + bar_width)
            ax.set_xticklabels(df_errors['precision'])
            ax.legend()
            
            # science notation for small numbers
            from matplotlib.ticker import ScalarFormatter
            ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))
            ax.ticklabel_format(axis='y', style='sci', scilimits=(-8,-3))
            
            # annotate bars
            for i, col in enumerate(['L1 Error','L2 Error','Linf Error']):
                v = df_errors[col].iloc[i]
                sign = 1 if v>=0 else -1
                offset = abs(v)*0.1
                ax.text(i + i*0*bar_width + (i)*bar_width, 
                        v + sign*offset, 
                        f"{v:.2e}",
                        ha='center',
                        va='bottom' if v>=0 else 'top',
                        rotation=90, fontsize=8)
            
            plt.tight_layout()
            output_file = os.path.join(OUTPUT_DIR, f"{equation_type}_error_comparison.png")
            plt.savefig(output_file, dpi=300, bbox_inches='tight')
            print(f"Saved error chart to {output_file}")
            plt.close()
        else:
            print(f"Warning: No valid error values for {equation_type}. Cannot create log-scale plot.")
            
        plt.close()
        
        # Print error table
        print("\nError Comparison Table:")
        print(df_errors.to_string(index=False, float_format='%.8e'))

def copy_summary_files():
    """Copy summary CSV files to output directory for reference."""
    summary_files = glob.glob(os.path.join(DATA_DIR, "*_summary.csv"))
    for file in summary_files:
        dest = os.path.join(OUTPUT_DIR, os.path.basename(file))

        shutil.copy2(file, dest)
        print(f"Copied {file} to {dest}")

def main():
    """Main function to control the workflow."""
    print("PDE Finite Element Method - Result Visualization")
    print("=" * 50)
    
    # Ensure output directory exists
    ensure_output_dir()
    
    # Ensure errors directory exists
    ensure_error_dir()
    
    # Check which files exist
    equation_types = ['heat', 'advection', 'burgers']
    precision_levels = ['FP16', 'FP32', 'FP64', 'FP128']
    
    for eq_type in equation_types:
        print(f"\nProcessing {eq_type.capitalize()} equation results:")
        
        # Create comparison plot
        available_precision = []
        for prec in precision_levels:
            if glob.glob(os.path.join(DATA_DIR, f"{eq_type}_{prec}_summary.csv")):
                available_precision.append(prec)
                print(f"  - Found data for {prec} precision")
        
        if available_precision:
            print(f"  - Creating comparison plot...")
            try:
                create_single_plot(eq_type, available_precision)
            except Exception as e:
                print(f"    Error creating comparison plot: {e}")
            
            # Create animations for each precision
            for prec in available_precision:
                print(f"  - Creating animation for {prec}...")
                try:
                    create_animation(eq_type, prec)
                except Exception as e:
                    print(f"    Error creating animation for {prec}: {e}")
            
            # Create a bar-chart if we have error files or an exact solution
            print("  - Creating error comparison…")
            try:
                create_error_comparison(eq_type)
            except Exception as e:
                print(f"    Error creating error comparison: {e}")
                
            # Plot conservation/decay
            print("  - Plotting conservation/decay …")
            try:
                plot_conservation(eq_type, available_precision)
            except Exception as e:
                print(f"    Error creating conservation plot: {e}")
        else:
            print(f"  - No data found for {eq_type} equation")
    
    # Copy summary files to output directory
    copy_summary_files()
    
    print("\nVisualization complete. Check the output files in the '{}' directory.".format(OUTPUT_DIR))

if __name__ == "__main__":
    main()